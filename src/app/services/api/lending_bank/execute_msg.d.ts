/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ExecuteMsg =
  | {
      receive: Cw20ReceiveMsg;
    }
  | {
      update_config: {
        /**
         * ibToken code id used to instantiate new tokens
         */
        ib_token_code_id?: number | null;
        /**
         * Address of protocol admin address Note that the admin of existing ibToken contracts need to be updated manually
         */
        protocol_admin_address?: string | null;
        /**
         * Address of reward collector address
         */
        protocol_rewards_collector_address?: string | null;
        [k: string]: unknown;
      };
    }
  | {
      init_asset: {
        /**
         * Asset related info
         */
        asset_info: AssetInfoBaseFor_String;
        /**
         * Asset parameters
         */
        asset_params: InitOrUpdateAssetParams;
        /**
         * Asset symbol to be used in ibToken name and description. If non is provided, denom will be used for native and token symbol will be used for cw20. Mostly useful for native assets since it's denom (e.g.: uluna, uusd) does not match it's user facing symbol (LUNA, UST) which should be used in ibToken's attributes for the sake of consistency
         */
        asset_symbol?: string | null;
        [k: string]: unknown;
      };
    }
  | {
      init_asset_token_callback: {
        /**
         * Either the denom for a terra native asset or address for a cw20 token in bytes
         */
        reference: number[];
        [k: string]: unknown;
      };
    }
  | {
      update_asset: {
        /**
         * Asset related info
         */
        asset_info: AssetInfoBaseFor_String;
        /**
         * Asset parameters
         */
        asset_params: InitOrUpdateAssetParams;
        [k: string]: unknown;
      };
    }
  | {
      update_uncollateralized_loan_limit: {
        /**
         * Asset the user receives the credit in
         */
        asset_info: AssetInfoBaseFor_String;
        /**
         * Limit for the uncolateralize loan.
         */
        new_limit: Uint128;
        /**
         * Address that receives the credit
         */
        user_address: string;
        [k: string]: unknown;
      };
    }
  | {
      deposit_native: {
        /**
         * Denom used in Terra (e.g: uluna, uusd)
         */
        denom: string;
        [k: string]: unknown;
      };
    }
  | {
      withdraw: {
        /**
         * Amount to borrow
         */
        amount?: Uint128 | null;
        /**
         * Asset to withdraw
         */
        asset_info: AssetInfoBaseFor_String;
        [k: string]: unknown;
      };
    }
  | {
      borrow: {
        /**
         * Amount to borrow
         */
        amount: Uint128;
        /**
         * Asset to borrow
         */
        asset_info: AssetInfoBaseFor_String;
        [k: string]: unknown;
      };
    }
  | {
      repay_native: {
        /**
         * Denom used in Terra (e.g: uluna, uusd)
         */
        denom: string;
        [k: string]: unknown;
      };
    }
  | {
      propose_new_owner: {
        /**
         * The validity period of the proposal to change the owner
         */
        expires_in: number;
        /**
         * The newly proposed owner
         */
        owner: string;
        [k: string]: unknown;
      };
    }
  | {
      drop_ownership_proposal: {
        [k: string]: unknown;
      };
    }
  | {
      claim_ownership: {
        [k: string]: unknown;
      };
    };
/**
 * A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.
 *
 * # Examples
 *
 * Use `from` to create instances of this and `u128` to get the value out:
 *
 * ``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);
 *
 * let b = Uint128::from(42u64); assert_eq!(b.u128(), 42);
 *
 * let c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```
 */
export type Uint128 = string;
/**
 * Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.
 *
 * This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>
 */
export type Binary = string;
/**
 * Represents the type of an fungible asset
 *
 * Each **asset info** instance can be one of two variants:
 *
 * - Native SDK coins. To create an **asset info** instance of this type, provide the denomination. - CW20 tokens. To create an **asset info** instance of this type, provide the contract address.
 */
export type AssetInfoBaseFor_String =
  | {
      native: string;
    }
  | {
      cw20: string;
    };
/**
 * A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0
 *
 * The greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)
 */
export type Decimal = string;
export type InterestRateModelParams = {
  linear: LinearInterestRateModelParams;
};

/**
 * Cw20ReceiveMsg should be de/serialized under `Receive()` variant in a ExecuteMsg
 */
export interface Cw20ReceiveMsg {
  amount: Uint128;
  msg: Binary;
  sender: string;
  [k: string]: unknown;
}
export interface InitOrUpdateAssetParams {
  /**
   * If false cannot do any action (deposit/withdraw/borrow/repay/liquidate)
   */
  active?: boolean | null;
  /**
   * If false cannot borrow
   */
  borrow_enabled?: boolean | null;
  /**
   * If false cannot deposit
   */
  deposit_enabled?: boolean | null;
  /**
   * Initial borrow rate
   */
  initial_borrow_rate?: Decimal | null;
  /**
   * Interest rate strategy to calculate borrow_rate and liquidity_rate
   */
  interest_rate_model_params?: InterestRateModelParams | null;
  /**
   * Portion of the borrow rate that is kept as protocol rewards
   */
  reserve_factor?: Decimal | null;
  [k: string]: unknown;
}
/**
 * Linear interest rate model
 */
export interface LinearInterestRateModelParams {
  /**
   * Base rate
   */
  base: Decimal;
  /**
   * Optimal utilization rate 1
   */
  optimal_utilization_rate_1: Decimal;
  /**
   * Optimal utilization rate 2
   */
  optimal_utilization_rate_2: Decimal;
  /**
   * Slope parameter for interest rate model function when utilization_rate <= optimal_utilization_rate
   */
  slope_1: Decimal;
  /**
   * Slope parameter for interest rate model function when optimal_utilization_rate < utilization_rate <= maximum_utilization_rate
   */
  slope_2: Decimal;
  /**
   * Slope parameter for interest rate model function when utilization_rate > maximum_utilization_rate
   */
  slope_3: Decimal;
  [k: string]: unknown;
}
